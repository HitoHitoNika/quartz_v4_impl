Back to [[00. Übersicht]]

Der Spring Container hilft uns Inversion of Control und Dependency Injection zu verwenden.
## Inversion of Control

> The approach of outsourcing the construction and management of objects

Wir wollen also die Objekterstellung und Verwaltung extern betreiben.

Wir könnten folgende Situation haben:

![[Spring Inversion of Control.png]]

Wie hier beschrieben möchten wir die Möglichkeit haben den Cricketcoach frei tauschen zu können bspw. mit einem Tenniscoach.

### Wie wendet man diese an?

Die Ideallösung wäre hier das wir eine "Object Factory" haben, welche an Hand unserer Konfiguration diesen Job übernimmt

![[Spring Inversion of Control 2.png]]

## Dependency Injection

> The client delegates to another object the responsibility of providing its dependencies.

Wir sagen also einem anderen Objekt das es sich um Objektabhängigkeiten kümmern soll.

### Beispiel

Man möchte ein Objekt Auto haben. Wie zuvor in [[11. Spring Container]] kennengelernt gibt es eine Factory die uns dieses Auto bereit stellt.

Jedoch hat unser Auto Abhängigkeiten zu Klassen wie "Tür","Motor",...

In diesem Falle übernimmt die Car Factory den Job Instanzen zu erstellen und diese unserem Auto mitzugeben.
![[Spring Dependency Injection.png]]

## Wie funktioniert das ganze in Spring?

In unserem Fall übernimmt Spring diesen Job, genauer der Spring Container.

Seine primären Funktionen sind:
- Objekt erstellen und verwalten ([[#Inversion of Control]])
- Abhängigkeiten injezieren ([[#Dependency Injection]])

Es gibt folgende Möglichkeiten den Spring Container zu konfigurieren:
- XML Datei (veraltet)
- Java Annotations (modern)
- Java Source Code (modern)

Der [[03. Spring REST Controller]] ist ein Beispiel hierfür.

Ein anderes Beispiel wäre der Fall, das wir einen Controller haben welcher eine Abhängigkeit zu einem Coach hat.
Der Coach stellt also eine Dependency da, welche injected werden muss.

![[Spring Depedency Injection Bsp.png]]

### Injection Types

In Spring gibt es mehrere Möglichkeiten Abhängigkeiten zu injezieren.

Die 2 wichtigen sind:
- Constructor Injection
	- Man sollte diese nutzen wenn es verpflichtende Abhängigkeiten gibt
	- Generell empfohlen von dem Team hinter Spring
- Setter Injection
	- Man sollte diese nutzen wenn man optionale Abhängigkeiten hat
	- Wenn die Dependency nicht zur Verfügung gestellt wurde, kann die App default Logik hinterlegen

### Spring AutoWiring

Für die Dependency Injection verwendet Spring autowiring. Spring sucht nach Klassen die gefordert sind und prüft diese auf Typen: Klassen oder Interface.

Genauer sucht Spring zunächst nach Klassen die mit @Component annotiert sind. Wenn wir uns auf das Beispiel des Coaches errinern, würde hier konkret gefragt werden "Hey, implementiert jemand das Coach-Interface". Wenn Spring also eine Klasse findet die das Coach interface implementiert nimmt er diese und erstellt eine Instanz, in unserem Beispiel der TennisCoach.

#### @Component annotation

- Markiert eine Klasse als Spring Bean
	- Spring Beans sind normale Java Klassen welche von Spring gemanaged werden
- Macht eine Bean verfügbar für dependency injection

#### Beispiel Code

Wir wollen folgende Beispiel Anwendung schreiben:

![[Pasted image 20231222102542.png]]

Der Entwicklungsprozess würde wie folgt aussehen:

1. Das Dependency Interface und die Klasse definieren
2. Demo REST Controller erstellen
3. Konstruktor für die Injection erstellen
4. @GetMapping für /dailyworkout hinterlegen

##### 1. Interface und Klasse definieren

Interface:

```java
public interface Coach{
	String getDailyWorkout();
}
```

Klasse:

```java
@Component
public class TennisCoach implements Coach{
	@Override
	public String getDailyWorkout(){
		return "Practice your serving for 15 Minutes";
	}
}
```

##### 2. Demo Rest Controller erstellen

```java
@RestController
public class DemoController{

}
```

##### 3. Konstruktor für die Injection erstellen

```java
@RestController
public class DemoController{

	private Coach myCoach;

	@Autowired
	public DemoController(Coach theCoach){
		myCoach = theCoach;
		//alternativ this.myCoach = theCoach;
	}
}
```

**Aktuell haben wir nur einen Coach, später werden Beispiele kommen mit mehreren Implementierungen**

##### 4. @GetMapping für /dailyworkout hinterlegen

```java
@RestController
public class DemoController{

	private Coach myCoach;

	@Autowired
	public DemoController(Coach theCoach){
		myCoach = theCoach;
	}

	@GetMapping("/dailyworkout")
	public String getDailyWorkout(){
		return myCoach.getDailyWorkout();
	}
}
```
